from pwn import remote, log
from base64 import b64decode, b64encode
from Crypto.Cipher import AES
from util import to_blocks, xor  # utility functions from code of challenge server


def split_iv_and_ctxt(s):
    s = b64decode(s)
    iv = s[:16]
    ctxt = s[16:]

    return {"iv": iv, "enced": ctxt}


def decrypt(cipher_text, key, iv):
    cipher_blocks = to_blocks(cipher_text)
    plain_blocks = []
    aes = AES.new(key, AES.MODE_ECB)

    for block in cipher_blocks:
        xored = aes.decrypt(block)
        plain = xor(xored, iv)
        plain_blocks.append(plain)
        iv = xor(plain, block)

    return b"".join(plain_blocks)


if __name__ == '__main__':
    target = "encryption.pwn2.win"
    port = 1337
    s = remote(target, port)
    print(s.recvuntil(": "))

    s.sendline(b"1")
    print(s.recvuntil(": "))
    pseudo_plain = b"unko"*4

    s.sendline(b64encode(pseudo_plain))
    first_res = s.recvline().rstrip()
    res_dic = split_iv_and_ctxt(first_res)
    next_key = xor(to_blocks(res_dic["enced"]))

    log.info(f"next key is {next_key}")

    print(s.recvuntil(": "))
    s.sendline(b"2")
    second_res = s.recvline().rstrip()
    res_dic = split_iv_and_ctxt(second_res)
    iv = res_dic["iv"]
    cipher_text = res_dic["enced"]

    log.info(f"iv is {iv}")

    print(decrypt(cipher_text, next_key, iv))

    s.close()
